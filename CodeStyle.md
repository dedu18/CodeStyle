## 一、发现的问题：
#### 项目： 现有项目名混乱、变量和方法等命名虽然驼峰且见名知意，但还是不统一规范、有硬编码魔法值存在、代码不整洁、业务线日志不清晰等
#### 个人：接口初期健壮性不够好，变量命名不够统一标准，日志注释格式不齐，代码还有很大优化空间

## 二、参考书籍：
#### 《clean code-代码整洁之道》、《重构改善既有代码的设计》

## 三、读书收获  
 - 1有意义的命名  
&nbsp;&nbsp;&nbsp;&nbsp;  1.1名副其实：代码模糊度：上下文在代码中未被明确体现的程度。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;  1.2避免误导：<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;  1.3做有意义的区分：光是使用数字系列或废话做区分远远不够，如Product、ProductInfo、ProductData没意义<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.4使用读的出来的名称：<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.5使用可搜索的名称：如变量ey和变量everyyear<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.6避免使用编码：如加上各种前缀m_、接口不加前导字母I，如AbstractFactory使用ShapeFactory和ShapeFactoryImp，因为不想让用户知道我给他们的是接口<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.7类名:应该是名词或名词短语，而不应是动词<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.8方法名:应当是动词或动词短语，如postPayment/deletePage/save，属性访问器、修改器、断言等应该根据其值命名并依造Javabean标准加上get、set、is前缀<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.9每个概念对应一个词：每个抽象概念选一个词并一以贯之，如fetch/get有啥区别？不要混用，选好一个之后在库中或项目中全都使用这个概念就好。一以贯之命名法也是福音。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.10别用双关语：避免将同一个单词用于不同目的。如好多个类中都有add方法，只要这些add方法参数列表和返回值在语义上等价就好。但如果业务语义确实不同，则果断用insert或append之类的词。即便违反了1.8的一以贯之<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.11添加有意义的语境:当firstName、lastName、state放一起时能知道state是地址相关，但单独使用时则无法判别，此时加上前缀addr组成addrState更好，或者单独封装Address类<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;1.12不要加没用语境：如Address类中accountAddress和customerAddress后缀多余，有类名和短名称就已经很清楚了。当然如果是MAC地址和Web地址则使用PostalAddress、MAC、URI更精准。<br/><br/>

 - 2函数  
&nbsp;&nbsp;&nbsp;&nbsp;2.1短小:每个函数大概都只有两行、三行或四行长，每个函数都一目了然，每个函数都只说一件事。if/else/while语句的代码块都只有一行，此行就是函数调用。函数体的缩进层次不应多余两层。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.2只做一件事:如果函数只做了该函数名下同一抽象层上的事则还是只做了一件事。只做一件事就是无法再被合理的拆分为多个片段。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.3每个函数一个抽象层:要让代码有自顶向下的阅读顺序，每个函数后面都跟着位于下一个抽象层级的代码。即要这样读程序：就像一些列To起头的段落，每个段落都描述当前抽象层级，并引用位于下一抽象层级的后续To起头段落。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.4switch语句:尝试使用多态来实现<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.5使用描述性名称:不要害怕长的函数名称，长而具有描述性的名称总比短而费解的名称好<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.6函数参数:最理想参数数量是0个，其次是1，再次是2，尽量避免3个，切忌有足够理由才用3个以上参数<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.7输出参数:应避免使用输出参数，如果函数要修改某种状态，就修改所属对象的状态，如appendFooter(s)和s.appendFooter()<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.8函数名称指令和询问分隔:如不要set()，而要setAndCheckIfExist()。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.9使用异常代替返回错误码，并抽离Try/Catch代码块另外形成函数。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.10错误处理就是一件事:如果try存在，则该是这个函数的第一个单词，且catch/finally代码块后面不该有其他内容。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.11结构化编程:每个函数、函数中每个代码块都应只有一个入口一个出口，即每个函数中只该有一个return，循环中不能有break或continue。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;2.11如何编写好的函数:写代码就像写文章，先想什么就写什么，然后打磨，初稿也许粗陋无序，你就斟酌推敲直到心中的样子。一开始都冗长复杂，有太多缩进和嵌套循环，过长的参数列表，名称随意或大量重复代码，但如果配上一套单元测试，覆盖代码然后打磨这些代码，分解函数，修改名称，消除重复，同时保持测试通过就好，没人能一开始就按照规则写。<br/><br/>

 - 3注释
 - 4格式
 - 5错误处理  
 &nbsp;&nbsp;&nbsp;&nbsp;5.1统一处理
 - 6单元测试  
&nbsp;&nbsp;&nbsp;&nbsp;6.1单个断言<br/>
&nbsp;&nbsp;&nbsp;&nbsp;6.2每个测试只测试一个概念<br/>
&nbsp;&nbsp;&nbsp;&nbsp;6.3FIRST:快速(First)测试应该够快运行/独立(Independent)测试应该互相独立/可重复(Repeatable)测试应当在任何环境重复通过/自足验证(Self-Validating)测试应有布尔值输出/及时(Timely)测试应及时编写<br/><br/>

 - 3类  
&nbsp;&nbsp;&nbsp;&nbsp;3.1类的组织:遵循标准Java约定，类应该从一组变量列表开始，如有公共静态变量应先出现，然后是私有静态变量以及私有实体变量，很少有公共变量。然后是公共函数，把该公共函数调用的私有函数紧跟其后，满足自顶向下原则。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;3.2类应该短小:①单一职责原则:类或模块应有且只有一条加以修改的理由，系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达到期望的系统行为。②内聚:类应该只有少数实体变量，如果类中的每个变量都被每个方法所使用，则此类具有最大的内聚性，反之则应分拆到更多类中。<br/><br/>

 - 4重构案例  
&nbsp;&nbsp;&nbsp;&nbsp;4.1简介:重构技术就是以微小的步伐修改程序。如果有了一套可靠的测试案例机制，即便你犯下错误，也会很容易便可发现它。【任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。】<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;4.2节奏:测试、小修改、测试、小修改······这种节奏让重构得以快速而安全的前进<br/><br/>

 - 5重构原则  
&nbsp;&nbsp;&nbsp;&nbsp;5.1Duplicated Code重复代码:如果在一个以上地点看到相同程序结构，就设法将它们合而为一。如同一个类的两个函数含有相同表达式、互为兄弟的子类内含相同表达式、毫不相关的类出现重复代码。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;5.2Long Method过长函数:程序越长越难理解，每当感觉需要以注释说明点什么的时候就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名，即便有时会只有一行或调用动作比函数自身还长。条件表达式和循环常常也是可以提炼。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;5.3Large Class过大的类:如果利用单个类做太多事情其内往往就会出现太多实例变量，一旦如此就可使用[5.1]处理。如果类内有太多代码重复、混乱则进行提取。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;5.4Long Parameter List过长参数列:使用对象，只需传给函数足够的，能让函数从中获得自己所需的东西即可。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;5.5Divergent Change发散式变化:如果某个类经常因为不同的原因在不同的方向上发生变化，则应是发散性变化。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化，为此应找出某特定原因而造成的所有变化然后将它们提炼到另一个类中。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;5.6Shotgun Surgery散弹式修改:与【5.5】相反，如果遇到某个变化，都必须在许多不同的类内做许多小修改，则需要把所有需要修改的代码放进同一个类，如果没有合适的类可放置则新建一个，否则修改的代码散布四处很难找到且易漏。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;5.7......:<br/><br/>

 - 6测试体系 
&nbsp;&nbsp;&nbsp;&nbsp;6.1测试的价值:类应该包含它们自己的测试代码。切勿着迷于增量式开发，尝试在结束每次增量时为每个类添加测试，然后需要做的就是把期望结果放进测试代码中，一切都没问题就输出一个OK即可。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;6.2测试编写时机:最有用的时机是在开始编程之前。编写测试代码其实就是在问自己这个功能需要做什么，预先写好的测试代码也是一个明确的结束标志，一旦测试代码正常运行，则工作结束。而对于重构，就必须编写测试代码。可使用assert或JUnit的Assert.assertEquals()<br/><br/>

 - 7重新组织函数  
&nbsp;&nbsp;&nbsp;&nbsp;7.1Extract Method提炼函数:①创造一个新函数，根据函数意图来命名，以它做什么来命名，而不是怎样做命名，如果想不到更有意义的名称，就别动。②无局部变量情况直接复制粘贴并插入函数调用动作即可。③有局部变量且目标函数仅是读取则简单地将这些变量当作参数传入函数。必要的话可以处理多个源函数的局部变量参数。④有局部变量且变量仅在目标函数中使用则可以把这些局部变量直接提炼到目标函数中。这样可以帮助减少局部变量。⑤有局部变量且变量在目标函数内和外都使用，则在目标函数中修改返回改变后的值。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.2Inline Method内联函数:①如果函数确定不具有多态性且函数本地和名称同样清楚易懂，则直接将函数体插入到调用处。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.3Inline Temp内联临时变量:①如果有一个临时变量仅被简单表达式赋值一次，则将用到它的地方直接替换为对它赋值的表达式本身。（可先将它声明为final确保编译没问题）<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.4Replace Temp With Query以查询取代临时变量:①如果程序以一个临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数中，将变量引用替换为函数调用，这样新函数就可被复用，利用提炼函数【7.1】。当然有时简单的话可以直接内联临时变量【7.3】<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.5Split Variable分解临时变量:①如有某个临时变量被赋值多次，且既不是循环变量也不用于收集结果，可针对每次赋值创造独立、对应的临时变量。否则变量就承担了多个任务。<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.6Remove Assignments To Parameters移除对参数的赋值:①在函数中，对于值传递，以一个临时变量取代该参数出现的位置。可在函数参数中使用final约束。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.7Replace Method With Method Object以函数对象取代函数:①将大型函数放进一个对象中，如此一来局部变量就成了对象内字段，就可在一个对象中将大型函数分解。
&nbsp;&nbsp;&nbsp;&nbsp;7.8Substitute Algorithm替换算法:①如果想将某个算法替换为另一个更清晰的算法，则将函数本体替换为另一个更简单的算法。
<br/><br/>

 - 8在对象之间搬移特性  
&nbsp;&nbsp;&nbsp;&nbsp;8.1Move Method搬移函数:①如果一个类有太多行为，或一个类与另一个类有太多合作而耦合，则在这个函数最多应用的类中创建一个类似行为的函数并将代码复制，且旧函数变成单纯的引用委托函数，或是直接删除。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;8.2Move Field搬移字段:①如果一类中某个字段被其他类更多的引用，则直接将这个字段搬到那个类中，并修改源类引用新字段（先看是否有现成字段和函数可帮助获得新字段值，没有则看是否可以新建函数帮助获取。）。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;8.3Extract Class提炼类:①如果一个类做了本应两个类做的事情，则新建一个类，将相关字段和函数从旧类搬移到新类。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;8.4Inline Class将类内联化:①如果某个类没有做太多事情，则将这个类的所有特性搬移到另一个类中并删除原类。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;8.5Hide Delegate隐藏委托关系:①如果客户通过一个委托类来调用另一个对象，则在这个服务类上建立客户所需的所有函数并隐藏委托关系。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;8.6Remove Hiddle Man移除中间人:①如果某个类做了太多的简单委托动作，则让客户直接调用受托类。
<br/><br/>

 - 9重新组织数据 
&nbsp;&nbsp;&nbsp;&nbsp;9.1Self Encapsulate Field自封装字段:①为对象创建Getter和Setter函数并通过这些函数访问字段。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;9.2Replace Data Value With Object以对象取代数据值:①有时某些数据关联性较大时，可将这些数据项封装成一个对象。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;9.3Change Value To Reference将值对象改成引用对象:①如果某个对象被多个其他对象引用，且该对象数据都是一样的，则可将该对象构造方法私有化并提供一个工厂方法如create()，然后创建缓存如HashMap保存加载好的对象，对象加载可在静态方法块中执行，然后在工厂方法中返回既存的对象。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;9.4Change Reference To Value将引用对象改成值对象:①与【9.3】相反，如果一个引用对象很小且是不可变对象，则考虑删除工厂方法并将构造函数声明为public，并重写equals和hashCode函数。
<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;9.5Replace Array With Object以对象取代数组:①如果有一个数组，如字符串数组，其中的元素各代表不同的东西，则考虑将这个数组封装成一个对象。
<br/><br/>